# Laboratory Work 5
> K33401 - Рейнгеверц В.А.


## Task 1
>
> Вор пробрался в музей и: 
> 
> - Хочет украсть $N$ экспонатов
> - У каждого экспоната есть свой вес и цена
> - Вор может сделать $M$ заходов, каждый раз унося $K$ кг веса.
> 
> Определить, что должен унести вор, чтобы сумма украденного была максимальной.

Экспонаты ― showpieces, были реализованы в виде списка объектов с ключами id, weight, price. Была создана вспомогательные функция calcWeight(showpieces), которая возвращает суммарный вес экспонатов в списке.
В качестве решения, был реализован жадный алгоритм в функции commitTheft(showpieces, totalRaids, weightLimit). После передачи экспонатов, указания количества заходов ― totalRaids, и лимит по весу на заход ― weightLimit, у экспонатов считается их ценность (отношение веса к цене) и, далее, каждый заход самые ценные экспонаты итеративно крадутся, пока не останется места в мешке вора.
На Рисунке 1 представлен анализ результата алгоритма. Было задано совершить 5 заходов, чтобы украсть 10 различных экспонатов, с мешком, рассчитанным на 5 кг.


![](https://i.imgur.com/zw6nYss.png)
Рисунок 1 ― Анализ жадного алгоритма кражи

По анализу, видно что локально оптимальный выбор экспонатов для кражи жадным алгоритмом не обязательно является оптимальным в целом ― в первом заходе алгоритм украл все высокоценные, килокрамове экспонаты, и потом уходил с неполностью забитым мешков последующих заходах. 

## Task 2
> Дана последовательность матриц $A$, $B$, $C$, … , $Z$ таким образом, что с ними можно выполнить ассоциативные операции. 
> 
> Используя динамическое программирование, минимизируйте количество скалярных операций для нахождения их произведения.


Для выполнения задания были созданы следующие вспомогательные функции:
–	matMul(a, b) ― возвращает произведение двух матриц,
–	matMulCount(a, b) ― возвращает количество индивидуальных умножений если умножить две матрицы,
–	matMulByOrder(matrixes, order) ― возвращает произведение всех переданных матриц ― matrixes, и количество индивидуальных умножений, исходя из порядка для их умножения ― order,
–	matMulOrderCombinations(matrixCount) ― возвращает все возможные порядки умножения матриц, в зависимости от числа матриц,
–	makeMultiplicableMatrices(n, maxDimention) ― возвращает упорядоченный список из n рандомных матриц, которые можно умножать друг с другом.
Динамический алгоритм умножений матриц был реализован в функции dynamicMatMulMinimize(matrices), где целевая функция ―  это matMulByOrder. Минимизация осуществляется за счет расчета количества индивидуальных умножений для всех возможных порядков умножения, и выбором наименьшего среди них. 
 
Результат работы алгоритма можно увидеть на Рисунке 2.

![](https://i.imgur.com/xwSFrpN.png)
Рисунок 2 ― Динамический алгоритм умножения матриц

Можно заметить, что для 3 матриц существует (3 – 1)! = 2! = 2 способа их перемножить, когда как для 10 уже (10 – 1)! = 9! = 362880 как на Рисунке 2. Для оптимизации подобной рекурсивной задачи стоит разбить ее на подзадачи и кешировать результаты их решений, чтобы устранить повторные вычисления.


## Task 3
> Дан:
> - Массив $N$
> - Cостоит из $n$ случайных целых чисел
> - Числа находятся в диапазоне от -100 до 100. 
>
> Найти наибольшую непрерывную возрастающую последовательность из чисел внутри массива 
> 
> Т.е. длину серии, для которой верно $N[i] < N[i+1] < N[i+2] < \text{...}\ < N[i+m]$, где 
> - $i\ge0$
> - $i+m \le n-1$.


Для нахождения наибольшей серии чисел, удовлетворяющей условию выше, была создан алгоритм findBiggestIncreasingSeries(array). 
В алгоритме используется объект series, символизирующей серию чисел из входного массива со следующими ключами:
–	startIndex ― индекс начала серии во входном массиве,
–	endIndex ― индекс конца серии во входном массиве,
–	values ― числовые значение серии.
Алгоритм проходит по элементам входного массива и создает, наполняет текущую серию ― currSeries. Если элемент массива нарушит целевое условие, то серия завершается, добавляется в список серий ― seriesList, и создается новая серия с этим элементом в ее начале. Если алгоритм доходит до конца входного массива, серия также завершается.
Далее список серий сортируется по убыванию количеству значений в серии и возвращается первая серия из списка.
 
Результат работы алгоритма можно увидеть на рисунке 3.

![](https://i.imgur.com/V9qnUzF.png)
Рисунок 3 ― Алгоритм нахождения наибольшей серии чисел

Алгоритм работает корректно.

## Running

```bash
npm install
```

```bash
npm run dev
```
